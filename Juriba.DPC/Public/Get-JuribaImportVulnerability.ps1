#Requires -Version 7
function Get-JuribaImportVulnerability {
    <#
        .SYNOPSIS
        Gets one or more vulnerabilities from the import API.

        .DESCRIPTION
        Gets a Vulnerability from the import API.
        Takes the ImportId as an input.
        Optionally takes a UniqueIdentifier as an input and will return a single Vulnerability with that UniqueIdentifier.
        Optionally takes a Name as an input and will return all Vulnerabilities matching that name.
        Optionally takes a Filter as an input and will return all Vulnerabilities matching that filter. See swagger documentation for examples of using filters.
        If specified, only one of UniqueIdentifier, Name or Filter can be supplied. Omit all to return all Vulnerabilities for the import.

        .PARAMETER Instance

        Optional. Instance to be provided if not authenticating using Connect-Juriba. For example, https://myinstance.platform.juriba.app:8443

        .PARAMETER APIKey

        Optional. API key to be provided if not authenticating using Connect-Juriba.

        .PARAMETER UniqueIdentifier

        UniqueIdentifier for the Vulnerability. Cannot be used with Name or Filter.

        .PARAMETER ImportId

        ImportId for the Vulnerability.

        .PARAMETER Name

        Name for the Vulnerability. Cannot be used with UniqueIdentifier or Filter.

        .PARAMETER Filter

        Filter for Vulnerability search. Cannot be used with Name or UniqueIdentifier.

        .PARAMETER Fields

        Array of fields to return. If specified, only these fields will be returned. This parameter is mutually exclusive with UniqueIdentifier and Filter.

        .PARAMETER InfoLevel

        Optional. Sets the level of information that this function returns. Accepts Basic or Full.
        Basic returns only the UniqueIdentifier, use when confirming a Vulnerability exists.
        Full returns the full json object for the Vulnerability.
        Default is Basic.

        .EXAMPLE
        PS> Get-JuribaImportVulnerability -Instance "https://myinstance.platform.juriba.app:8443" -APIKey "xxxxx" -ImportId 1 -InfoLevel "Full"

        .EXAMPLE
        PS> Get-JuribaImportVulnerability -Instance "https://myinstance.platform.juriba.app:8443" -APIKey "xxxxx" -ImportId 1 -UniqueIdentifier "CVE-1999-0095" -InfoLevel "Basic"

        .EXAMPLE
        PS> Get-JuribaImportVulnerability -Instance "https://myinstance.platform.juriba.app:8443" -APIKey "xxxxx" -ImportId 1 -Name "CVE-1999-0095"

        .EXAMPLE
        PS> Get-JuribaImportVulnerability -Instance "https://myinstance.platform.juriba.app:8443" -APIKey "xxxxx" -ImportId 1 -Filter "eq(severityScore, '3.6')"

    #>
    [OutputType([Object[]])]
    [CmdletBinding(DefaultParameterSetName="Default")]
    param (
        [Parameter(Mandatory=$false)]
        [string]$Instance,
        [Parameter(Mandatory=$false)]
        [string]$APIKey,
        [Parameter(Mandatory=$false, ParameterSetName="UniqueIdentifier")]
        [string]$UniqueIdentifier,
        [Parameter(Mandatory=$false, ParameterSetName="Name")]
        [string]$Name,
        [Parameter(Mandatory=$false, ParameterSetName="Filter")]
        [string]$Filter,
        [Parameter(Mandatory=$true)]
        [int]$ImportId,
        [Parameter(Mandatory=$false)]
        [ValidateSet("Basic", "Full")]
        [string]$InfoLevel = "Basic",
        [Parameter(Mandatory=$false ,ParameterSetName="fields")]
        [string[]]$Fields,
        [Parameter(Mandatory=$false)]
        [int]$PageSize = 200
    )
    if ((Get-Variable 'dwConnection' -Scope 'Global' -ErrorAction 'Ignore') -and !$APIKey -and !$Instance) {
        $APIKey = ConvertFrom-SecureString -SecureString $dwConnection.secureAPIKey -AsPlainText
        $Instance = $dwConnection.instance
    }

    if ($APIKey -and $Instance) {
        $uri = "{0}/apiv2/imports/{1}/vulnerabilities" -f $Instance, $ImportId
    
        #build query string
        $query = @()

        # add limit to query if not getting by UniqueIdentifier
        if ($PSCmdlet.ParameterSetName -ne "UniqueIdentifier") {
            $query += "limit=$PageSize"
        }
        
        # add parameters to query based on parameter set
        switch ($PSCmdlet.ParameterSetName) {
            "UniqueIdentifier" {
                $uri += "/{0}" -f $UniqueIdentifier
            }
            "Filter" {
                $query += "filter={0}" -f [System.Web.HttpUtility]::UrlEncode($Filter)
            }
            "Fields" {
                $query += "fields={0}" -f [System.Web.HttpUtility]::UrlEncode($Fields -join ',')
                $InfoLevel = "Full"
            }
            "Name" {
                $query += "filter={0}" -f [System.Web.HttpUtility]::UrlEncode("eq(name,'{0}')" -f $Name)
            }
            Default { }
        }

        # build final uri
        if ($query.Count -gt 0) {
            $uri += $query | Join-String -Property $_ -Separator "&" -OutputPrefix "?"
        }
    
        $headers = @{
            'x-api-key' = $APIKey
            'cache-control' = 'no-cache'
        }
    
        $vulnerability = @()
        try {
            $result = Invoke-WebRequest -Uri $uri -Method GET -Headers $headers -ContentType "application/json"
            if ($result.Content -eq '[]') {return $vulnerability}
            $vulnerability = switch($InfoLevel) {
                "Basic" { ($result.Content | ConvertFrom-Json).UniqueIdentifier }
                "Full"  { $result.Content | ConvertFrom-Json }
            }
            # check if result is paged, if so get remaining pages and add to result set
            if ($result.Headers.ContainsKey("X-Pagination")) {
                $totalPages = ($result.Headers."X-Pagination" | ConvertFrom-Json).totalPages
                for ($page = 2; $page -le $totalPages; $page++) {
                    if ($uri -match '\?') {
                        $pagedUri = $uri + "&page={0}" -f $page
                    } else {
                        $pagedUri = $uri + "?page={0}" -f $page
                    }
                    $pagedResult = Invoke-WebRequest -Uri $pagedUri -Method GET -Headers $headers -ContentType "application/json"
                    $vulnerability += switch($InfoLevel) {
                        "Basic" { ($pagedResult.Content | ConvertFrom-Json).UniqueIdentifier }
                        "Full"  { $pagedResult.Content | ConvertFrom-Json }
                    }
                }
            }
            return $vulnerability
        }
        catch { 
            if ($_.Exception.Response.StatusCode.Value__ -eq 404) {
                # 404 means the Vulnerability was not found, don't treat this as an error
                # as we expect this function to be used to check if a Vulnerability exists
                Write-Verbose "Vulnerability not found"
            } else {
                Write-Error $_
            }
        }

    } else {
        Write-Error "No connection found. Please ensure `$APIKey and `$Instance is provided or connect using Connect-Juriba before proceeding."
    }
}
